rm(list = ls()); gc()

suppressPackageStartupMessages({
  library(tidyverse)
  library(scales)
})

# ------------------------------- #
# User settings                   #
# ------------------------------- #

root            <- "mgdriveSIT_sweep_10yr"   # parent folder with param-tag subfolders
years_window    <- 10                        # compute min/max over first N years
days_per_year   <- 365
fy_keep         <- 0.50                      # keep only fy ≈ 0.5
runs_expect     <- sprintf("%03d", 1:10)     # expected run folders

# ------------------------------- #
# Helpers (your originals)        #
# ------------------------------- #

read_ts_csv <- function(path) {
  df <- readr::read_csv(path, show_col_types = FALSE, progress = FALSE)
  if (!"Time" %in% names(df)) stop(sprintf("'Time' column not found in %s", basename(path)))
  df <- df %>% mutate(Time = suppressWarnings(as.numeric(Time))) %>% arrange(Time)
  if (anyNA(df$Time)) stop(sprintf("Non-numeric 'Time' values in %s", basename(path)))
  df
}

parse_num_from_tag <- function(tag, key) {
  m <- stringr::str_match(tag, paste0("(^|_)", key, "([-0-9p]+)"))[,3]
  if (is.na(m)) return(NA_real_)
  as.numeric(sub("p", ".", m, fixed = TRUE))
}

parse_param_tags <- function(tag,
                             defaults = list(rel = NA_real_, fy = NA_real_, pq = NA_real_,
                                             fl = NA_real_, mu = NA_real_, j = NA_real_, c = NA_real_)) {
  vals <- list(
    rel = parse_num_from_tag(tag, "rel"),
    fy  = parse_num_from_tag(tag, "fy"),
    pq  = parse_num_from_tag(tag, "pq"),
    fl  = parse_num_from_tag(tag, "fl"),
    mu  = parse_num_from_tag(tag, "mu"),
    j   = parse_num_from_tag(tag, "j"),
    c   = parse_num_from_tag(tag, "c")
  )
  for (k in names(vals)) if (is.na(vals[[k]]) && !is.null(defaults[[k]])) vals[[k]] <- defaults[[k]]
  tibble::tibble(rel = vals$rel, fy = vals$fy, pq = vals$pq, fl = vals$fl,
                 mu = vals$mu, j = vals$j, c = vals$c)
}

# ------------------------------- #
# File readers for totals         #
# ------------------------------- #

# Try (1) explicit female+male CSVs; else (2) any CSV with a "total" column
read_totals_from_run <- function(run_dir) {
  # Pattern 1: Female aggregate + Male (as in your prior workflow)
  f_path <- list.files(run_dir, pattern = "^F_.*Aggregate.*\\.csv$", full.names = TRUE)
  m_path <- list.files(run_dir, pattern = "^M_.*\\.csv$",               full.names = TRUE)
  if (length(f_path) && length(m_path)) {
    fdf <- read_ts_csv(f_path[1]); mdf <- read_ts_csv(m_path[1])
    f_cols <- grep("^f", names(fdf), value = TRUE)
    m_cols <- grep("^m", names(mdf), value = TRUE)
    female_total <- if ("female_total" %in% names(fdf)) fdf$female_total else {
      if (length(f_cols)) rowSums(fdf[, f_cols, drop = FALSE]) else rep(NA_real_, nrow(fdf))
    }
    male_total <- if (length(m_cols)) rowSums(mdf[, m_cols, drop = FALSE]) else rep(NA_real_, nrow(mdf))
    df <- inner_join(
      fdf %>% select(Time) %>% mutate(female_total = as.numeric(female_total)),
      mdf %>% select(Time) %>% mutate(male_total   = as.numeric(male_total)),
      by = "Time"
    ) %>% arrange(Time) %>%
      mutate(total_adults = female_total + male_total)
    return(df %>% select(Time, total_adults))
  }
  
  # Pattern 2: Any CSV with a sensible total column
  any_csv <- list.files(run_dir, pattern = "\\.csv$", full.names = TRUE)
  if (length(any_csv)) {
    df <- read_ts_csv(any_csv[1])
    ln <- tolower(names(df))
    cand <- c("total_mean","total","total_adults","n_total","ntotal")
    pick <- cand[match(cand, ln, nomatch = 0) > 0]
    if (length(pick)) {
      col <- names(df)[match(pick[1], ln)]
      return(df %>% transmute(Time, total_adults = as.numeric(.data[[col]])))
    }
  }
  
  stop(sprintf("Could not find F/M pair or a 'total' column in %s", run_dir))
}

# Per-run extrema over the first `years_window` years
run_extrema_10y <- function(run_dir) {
  df <- read_totals_from_run(run_dir)
  cutoff <- years_window * days_per_year
  df10 <- df %>% filter(Time <= cutoff)
  tibble(
    run_dir  = run_dir,
    run_id   = basename(run_dir),
    max_total_10y = max(df10$total_adults, na.rm = TRUE),
    min_total_10y = min(df10$total_adults, na.rm = TRUE)
  )
}

# ------------------------------- #
# Scan folders, build per-run     #
# ------------------------------- #

stopifnot(dir.exists(root))
param_dirs <- list.dirs(root, recursive = FALSE, full.names = TRUE)
stopifnot(length(param_dirs) > 0)

per_run_tbl <- purrr::map_dfr(param_dirs, function(pdir) {
  tag <- basename(pdir)
  pars <- parse_param_tags(tag)
  # Keep only fy ≈ 0.5
  if (!is.finite(pars$fy) || abs(pars$fy - fy_keep) > 1e-8) return(tibble())
  
  run_dirs <- list.dirs(pdir, recursive = FALSE, full.names = TRUE)
  run_dirs <- run_dirs[basename(run_dirs) %in% runs_expect]
  if (!length(run_dirs)) return(tibble())
  
  purrr::map_dfr(run_dirs, function(rd) {
    ext <- tryCatch(run_extrema_10y(rd), error = function(e) tibble())
    if (!nrow(ext)) return(tibble())
    ext %>% mutate(tag = tag, rel = pars$rel, fy = pars$fy)
  })
})

stopifnot(nrow(per_run_tbl) > 0)
per_run_long <- per_run_tbl %>%
  pivot_longer(c(max_total_10y, min_total_10y), names_to = "stat", values_to = "value") %>%
  mutate(stat = recode(stat, max_total_10y = "max", min_total_10y = "min"))

# ------------------------------- #
# Summaries with 95% CI           #
# ------------------------------- #

summ_tbl <- per_run_long %>%
  group_by(rel, stat) %>%
  summarise(
    n = n(),
    mean = mean(value, na.rm = TRUE),
    sd   = sd(value, na.rm = TRUE),
    se   = sd / sqrt(n),
    tval = qt(0.975, df = pmax(n - 1, 1)),
    lo   = mean - tval * se,
    hi   = mean + tval * se,
    .groups = "drop"
  ) %>%
  arrange(rel, stat)

# ------------------------------- #
# Plots                           #
# ------------------------------- #

p_ci <- ggplot(summ_tbl, aes(x = rel, y = mean, color = stat, group = stat)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = lo, ymax = hi), width = 0) +
  scale_x_log10(labels = label_number(accuracy = 1)) +
  labs(x = "Release size (log10)", y = "Total adults", color = NULL,
       title = sprintf("Max / Min total adults vs release (first %d years, fy=%.2f)", years_window, fy_keep)) +
  theme_bw()

p_violin <- ggplot(per_run_long, aes(x = stat, y = value)) +
  geom_violin(trim = FALSE) +
  geom_jitter(width = 0.08, height = 0, alpha = 0.6, size = 1) +
  facet_wrap(~ scales::number(rel), nrow = 1) +
  labs(x = NULL, y = "Total adults",
       title = sprintf("Per-run distributions of max/min by release (first %d years, fy=%.2f)", years_window, fy_keep)) +
  theme_bw()

print(p_ci)
print(p_violin)

# ------------------------------- #
# Optional: save CSVs & figures   #
# ------------------------------- #

out_dir <- file.path(root, "sit_extrema_10y_outputs")
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

readr::write_csv(per_run_tbl, file.path(out_dir, "per_run_extrema_10y.csv"), na = "")
readr::write_csv(summ_tbl,    file.path(out_dir, "summary_extrema_10y.csv"),   na = "")

# ggsave(file.path(out_dir, "sit_extrema_10y_CI.png"), p_ci, width = 7, height = 4.5, dpi = 300)
# ggsave(file.path(out_dir, "sit_extrema_10y_violins.png"), p_violin, width = 11, height = 3.8, dpi = 300)
